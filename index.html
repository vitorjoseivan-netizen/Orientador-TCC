<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Orientador de TCC Digital</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">

  <!-- PDF.js (leitura real de PDF) -->
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.min.js"></script>

  <!-- Exportar DOCX -->
  <script src="https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <style>
    :root{
      --bg0:#0b1020;
      --bg1:#0f1630;
      --card:rgba(255,255,255,.06);
      --card2:rgba(255,255,255,.08);
      --line:rgba(255,255,255,.14);
      --text:#eef3ff;
      --muted:#b8c4ea;

      --p1:#7c5cff;
      --p2:#33d69f;
      --p3:#ffd15c;
      --danger:#ff5c7c;

      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --r12:12px;
      --r16:16px;
      --r22:22px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 12% 0%, rgba(124,92,255,.28), transparent 60%),
        radial-gradient(1000px 700px at 90% 10%, rgba(51,214,159,.18), transparent 55%),
        radial-gradient(900px 600px at 50% 90%, rgba(255,209,92,.12), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow:hidden;
    }

    /* topo com glow */
    .topbar{
      height:64px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 18px;
      border-bottom:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
      backdrop-filter: blur(10px);
    }
    .brand{display:flex;flex-direction:column;gap:2px;min-width:0}
    .brand .t{font-weight:900;letter-spacing:.2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .brand .s{font-size:12px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

    .chip{
      display:inline-flex;align-items:center;gap:10px;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      font-size:12px;
      color:var(--muted);
      user-select:none;
    }
    .dot{width:10px;height:10px;border-radius:50%;background:var(--p3);box-shadow:0 0 0 4px rgba(255,209,92,.15)}
    .dot.ok{background:var(--p2);box-shadow:0 0 0 4px rgba(51,214,159,.14)}
    .dot.bad{background:var(--danger);box-shadow:0 0 0 4px rgba(255,92,124,.16)}

    .layout{
      height:calc(100vh - 64px);
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:14px;
      padding:14px;
    }

    .panel{
      border:1px solid var(--line);
      border-radius:var(--r22);
      background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      box-shadow:var(--shadow);
      overflow:hidden;
      min-width:0;
      display:flex;
      flex-direction:column;
    }

    .panelHead{
      padding:14px 14px 12px;
      border-bottom:1px solid var(--line);
      background:rgba(255,255,255,.03);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .panelHead h3{
      margin:0;
      font-size:12px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:var(--muted);
      font-weight:900;
    }

    .scroll{overflow:auto; padding:14px;}
    .card{
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      border-radius:var(--r16);
      padding:12px;
      margin-bottom:12px;
    }
    .card h4{
      margin:0 0 10px;
      font-size:12px;
      color:var(--muted);
      font-weight:900;
      letter-spacing:.12em;
      text-transform:uppercase;
    }

    .btn{
      appearance:none;
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--text);
      border-radius:14px;
      padding:10px 12px;
      font-weight:900;
      font-size:13px;
      cursor:pointer;
      transition:.15s ease;
      display:inline-flex;
      gap:8px;
      align-items:center;
      user-select:none;
    }
    .btn:hover{transform:translateY(-1px);border-color:rgba(255,255,255,.22)}
    .btn.primary{
      background:linear-gradient(180deg, rgba(124,92,255,.95), rgba(124,92,255,.75));
      border-color:rgba(124,92,255,.60);
    }
    .btn.success{
      background:linear-gradient(180deg, rgba(51,214,159,.35), rgba(51,214,159,.18));
      border-color:rgba(51,214,159,.35);
    }
    .btn.danger{
      background:linear-gradient(180deg, rgba(255,92,124,.25), rgba(255,92,124,.10));
      border-color:rgba(255,92,124,.35);
    }
    .btn.ghost{background:transparent}

    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .hint{font-size:12px;color:var(--muted);line-height:1.45}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:11px;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.25);
      color:var(--muted);
    }

    /* Etapas */
    .steps{display:flex;flex-direction:column;gap:8px}
    .step{
      display:flex;gap:10px;align-items:flex-start;
      border:1px solid transparent;
      background:rgba(255,255,255,.04);
      padding:10px;
      border-radius:16px;
      cursor:pointer;
      transition:.15s ease;
    }
    .step:hover{border-color:rgba(124,92,255,.45); background:rgba(124,92,255,.12)}
    .step.active{border-color:rgba(124,92,255,.7); background:rgba(124,92,255,.18)}
    .num{
      width:26px;height:26px;border-radius:10px;
      background:rgba(124,92,255,.25);
      border:1px solid rgba(124,92,255,.35);
      display:flex;align-items:center;justify-content:center;
      font-weight:900;font-size:12px;
      flex:0 0 auto;
    }
    .meta{min-width:0}
    .meta .title{font-weight:900;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .meta .sub{font-size:12px;color:var(--muted)}

    /* Main */
    .mainTop{
      padding:14px;
      border-bottom:1px solid var(--line);
      background:rgba(255,255,255,.03);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    .mainTop .left{min-width:0}
    .mainTop .left .h{
      margin:0;
      font-size:18px;
      font-weight:1000;
      letter-spacing:.2px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .mainTop .left .d{
      margin:6px 0 0;
      font-size:12px;
      color:var(--muted);
      line-height:1.45;
    }

    .toggle{
      display:flex;align-items:center;gap:10px;
      padding:8px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background:rgba(0,0,0,.18);
      user-select:none;
    }
    .toggle input{
      width:44px;height:24px;
      appearance:none;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.08);
      position:relative;
      cursor:pointer;
      outline:none;
      transition:.15s ease;
    }
    .toggle input:checked{
      background:rgba(51,214,159,.22);
      border-color:rgba(51,214,159,.35);
    }
    .toggle input::after{
      content:"";
      width:18px;height:18px;border-radius:50%;
      position:absolute;top:50%;left:4px;
      transform:translateY(-50%);
      background:rgba(255,255,255,.9);
      transition:.15s ease;
    }
    .toggle input:checked::after{left:22px;}
    .toggle span{font-size:12px;font-weight:900}

    .content{
      display:grid;
      grid-template-rows: 1fr auto;
      height:100%;
      overflow:hidden;
    }
    .work{
      padding:14px;
      overflow:auto;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .box{
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      border-radius:var(--r16);
      padding:12px;
      min-width:0;
    }
    .box h4{
      margin:0 0 10px;
      font-size:12px;
      color:var(--muted);
      font-weight:900;
      letter-spacing:.12em;
      text-transform:uppercase;
    }

    textarea{
      width:100%;
      min-height:260px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      color:var(--text);
      border-radius:14px;
      padding:12px;
      font-size:13px;
      line-height:1.55;
      outline:none;
      resize:vertical;
    }
    textarea:focus{
      border-color:rgba(124,92,255,.7);
      box-shadow:0 0 0 4px rgba(124,92,255,.15);
    }

    .out{
      white-space:pre-wrap;
      word-break:break-word;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      border-radius:14px;
      padding:12px;
      min-height:210px;
      overflow:auto;
      font-size:12.5px;
      line-height:1.55;
    }

    .statusbar{
      padding:10px 14px;
      border-top:1px solid var(--line);
      background:rgba(255,255,255,.03);
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      font-size:12px;
      color:var(--muted);
    }
    .statusbar b{color:var(--text)}

    /* PDFs list */
    input[type="file"]{display:none}
    .fileList{display:flex;flex-direction:column;gap:10px;max-height:260px;overflow:auto;padding-right:4px;}
    .fileItem{
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      border-radius:14px;
      padding:10px;
    }
    .fileTop{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
    .fileName{font-size:12px;font-weight:1000;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:0}
    .fileMeta{font-size:12px;color:var(--muted);margin-top:4px}
    .small{padding:8px 10px;font-size:12px;border-radius:12px}

    @media (max-width: 980px){
      body{overflow:auto}
      .layout{grid-template-columns:1fr;height:auto}
      .grid2{grid-template-columns:1fr}
    }

    @media print{
      body{background:#fff;color:#000}
      .topbar,.panel:first-child,.mainTop,.statusbar,.btn,.toggle{display:none!important}
      .panel{border:none;box-shadow:none}
      textarea,.out{background:#fff;border:1px solid #ddd;color:#000}
      .layout{padding:0}
      .work{padding:0}
    }
  </style>
</head>

<body>
  <header class="topbar">
    <div class="brand">
      <div class="t">Orientador de TCC Digital</div>
      <div class="s">Layout moderno + leitura real de PDF (PDF.js) + Worker Cloudflare (POST /assist)</div>
    </div>
    <div class="chip">
      <span id="svcDot" class="dot"></span>
      <span>Backend: <b id="svcText">verificando…</b></span>
    </div>
  </header>

  <div class="layout">
    <!-- SIDEBAR -->
    <aside class="panel">
      <div class="panelHead">
        <h3>Etapas</h3>
        <button class="btn ghost small" id="resetAllBtn" type="button">Reset</button>
      </div>
      <div class="scroll">
        <div class="card">
          <h4>Navegação</h4>
          <div class="steps" id="steps"></div>
          <div class="hint" style="margin-top:10px;">
            Dica: o progresso é salvo automaticamente no seu navegador.
          </div>
        </div>

        <div class="card">
          <h4>Anexos (PDF) — leitura real</h4>
          <div class="row" style="margin-bottom:10px;">
            <label class="btn success" for="pdfInput">Anexar PDF</label>
            <input id="pdfInput" type="file" accept="application/pdf" multiple />
            <button class="btn danger" id="clearPdfsBtn" type="button">Limpar</button>
          </div>

          <div class="row" style="margin-bottom:10px;">
            <div style="flex:1;min-width:140px;">
              <div class="hint"><b>Máx. páginas</b></div>
              <input id="maxPages" type="number" min="1" max="200" value="30"
                     style="width:100%;padding:10px;border-radius:14px;border:1px solid var(--line);background:rgba(255,255,255,.04);color:var(--text);font-weight:900;outline:none;">
            </div>
            <div style="flex:1;min-width:140px;">
              <div class="hint"><b>Máx. caracteres</b></div>
              <input id="maxChars" type="number" min="5000" max="300000" value="60000"
                     style="width:100%;padding:10px;border-radius:14px;border:1px solid var(--line);background:rgba(255,255,255,.04);color:var(--text);font-weight:900;outline:none;">
            </div>
          </div>

          <div class="hint" style="margin-bottom:10px;">
            Extração por páginas: <span class="kbd">1-3, 7, 10-12</span>. PDFs escaneados (imagem) podem vir vazios (precisa OCR).
          </div>

          <div class="fileList" id="pdfList"></div>
        </div>

        <div class="card">
          <h4>Exportação</h4>
          <div class="row">
            <button class="btn" id="exportPdfBtn" type="button">Exportar PDF</button>
            <button class="btn" id="exportDocxBtn" type="button">Exportar DOCX</button>
          </div>
          <div class="hint" style="margin-top:10px;">
            PDF é via impressão do navegador. DOCX gera um Word simples da etapa atual.
          </div>
        </div>
      </div>
    </aside>

    <!-- MAIN -->
    <main class="panel">
      <div class="mainTop">
        <div class="left">
          <h1 class="h" id="stepTitle">—</h1>
          <p class="d" id="stepDesc">—</p>
        </div>
        <div class="row" style="justify-content:flex-end">
          <div class="toggle">
            <input id="evidenceToggle" type="checkbox" />
            <span>Modo Evidência</span>
          </div>
          <button class="btn" id="saveBtn" type="button">Salvar</button>
          <button class="btn primary" id="askBtn" type="button">Orientar com IA</button>
          <button class="btn danger" id="clearStepBtn" type="button">Limpar etapa</button>
        </div>
      </div>

      <div class="content">
        <div class="work">
          <div class="grid2">
            <section class="box">
              <h4>Seu texto</h4>
              <textarea id="userText" placeholder="Escreva aqui o conteúdo desta etapa..."></textarea>
              <div class="row" style="justify-content:space-between">
                <div class="hint">Último salvamento: <b id="lastSaved">—</b></div>
                <div class="hint">Progresso: <b id="progress">0%</b></div>
              </div>
            </section>

            <section class="box">
              <h4>Evidências (PDF / anotações)</h4>
              <textarea id="evidenceText" placeholder="Aqui entram os trechos extraídos do PDF e/ou suas anotações..."></textarea>
              <div class="hint">
                Use os botões dos PDFs para extrair texto aqui. No Modo Evidência, a IA deve justificar com base neste campo.
              </div>
            </section>
          </div>

          <section class="box" style="margin-top:12px;">
            <h4>Resposta da IA</h4>
            <div id="aiOut" class="out">—</div>
          </section>
        </div>

        <footer class="statusbar">
          <span>Status: <b id="runtimeStatus">pronto</b></span>
          <span>Endpoint: <b id="endpointText">—</b></span>
        </footer>
      </div>
    </main>
  </div>

  <script>
    /**************************************************************
     * CONFIGURAÇÃO OBRIGATÓRIA (corrige o HTTP 405)
     * Cole aqui o link do seu Worker Cloudflare, exemplo:
     * const WORKER_BASE = "https://orientador-tcc-api.vitorjoselvan.workers.dev";
     **************************************************************/
    const WORKER_BASE = "COLE_AQUI_O_LINK_DO_SEU_WORKER"; // <-- TROQUE ISTO

    // PDF.js worker src
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.worker.min.js";
    }

    const STEPS = [
      { id: "tema", title: "Tema / Introdução", desc: "Delimite o tema e contextualize o problema." },
      { id: "problema", title: "Problema de Pesquisa", desc: "Formule a pergunta central e o recorte." },
      { id: "objetivos", title: "Objetivos", desc: "Geral e específicos (com verbos no infinitivo)." },
      { id: "justificativa", title: "Justificativa", desc: "Relevância acadêmica e social; por que vale pesquisar." },
      { id: "referencial", title: "Referencial Teórico", desc: "Base conceitual (autores, conceitos, categorias)." },
      { id: "metodologia", title: "Metodologia", desc: "Abordagem, tipo de pesquisa, técnicas e instrumentos." },
      { id: "cronograma", title: "Cronograma", desc: "Planejamento por etapas e prazos." },
      { id: "elementos", title: "Elementos Pré-textuais", desc: "Resumo, palavras-chave, abstract, etc." },
      { id: "referencias", title: "Referências", desc: "Lista final em padrão exigido." }
    ];

    const STORE_KEY = "orientador_tcc_v4";
    const STORE_ACTIVE = "orientador_active_step_v4";
    const STORE_EVID = "orientador_evidence_v4";
    const STORE_EVID_TOGGLE = "orientador_evidence_toggle_v4";
    const STORE_PDFS = "orientador_pdfs_v4"; // guarda PDFs em base64 + metadados

    const $ = (id) => document.getElementById(id);

    const stepsEl = $("steps");
    const stepTitleEl = $("stepTitle");
    const stepDescEl = $("stepDesc");
    const userTextEl = $("userText");
    const evidenceTextEl = $("evidenceText");
    const aiOutEl = $("aiOut");
    const lastSavedEl = $("lastSaved");
    const progressEl = $("progress");
    const runtimeStatusEl = $("runtimeStatus");
    const endpointTextEl = $("endpointText");

    const pdfInputEl = $("pdfInput");
    const pdfListEl = $("pdfList");
    const clearPdfsBtn = $("clearPdfsBtn");
    const maxPagesEl = $("maxPages");
    const maxCharsEl = $("maxChars");

    const saveBtn = $("saveBtn");
    const askBtn = $("askBtn");
    const clearStepBtn = $("clearStepBtn");
    const resetAllBtn = $("resetAllBtn");
    const exportPdfBtn = $("exportPdfBtn");
    const exportDocxBtn = $("exportDocxBtn");
    const evidenceToggleEl = $("evidenceToggle");

    const svcDot = $("svcDot");
    const svcText = $("svcText");

    // Endpoints: sempre no Worker (não no GitHub Pages)
    const API_BASE = normalizeWorkerBase(WORKER_BASE);
    const ENDPOINT_ASSIST = API_BASE ? (API_BASE + "/assist") : "/assist";
    const ENDPOINT_HEALTH = API_BASE ? (API_BASE + "/health") : "/health";
    endpointTextEl.textContent = ENDPOINT_ASSIST;

    let activeStep = localStorage.getItem(STORE_ACTIVE) || STEPS[0].id;

    function normalizeWorkerBase(v){
      const s = (v || "").trim();
      if(!s || s === "COLE_AQUI_O_LINK_DO_SEU_WORKER") return "";
      return s.replace(/\/+$/,"");
    }

    function setSvc(type, text){
      svcText.textContent = text;
      svcDot.classList.remove("ok","bad");
      if(type === "ok") svcDot.classList.add("ok");
      if(type === "bad") svcDot.classList.add("bad");
    }

    function escapeHtml(str){
      return (str || "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function clampInt(v, min, max, fallback){
      const n = parseInt(v, 10);
      if(Number.isNaN(n)) return fallback;
      return Math.max(min, Math.min(max, n));
    }

    function loadStore(){
      try { return JSON.parse(localStorage.getItem(STORE_KEY) || "{}"); } catch { return {}; }
    }
    function saveStore(data){
      localStorage.setItem(STORE_KEY, JSON.stringify(data));
      lastSavedEl.textContent = new Date().toLocaleString();
      updateProgress();
    }

    function loadPdfs(){
      try { return JSON.parse(localStorage.getItem(STORE_PDFS) || "[]"); } catch { return []; }
    }
    function savePdfs(list){
      localStorage.setItem(STORE_PDFS, JSON.stringify(list));
      renderPdfs();
    }

    function prettyBytes(bytes){
      const units = ["B","KB","MB","GB"];
      let i = 0, n = bytes || 0;
      while(n >= 1024 && i < units.length-1){ n/=1024; i++; }
      return `${n.toFixed(i===0?0:1)} ${units[i]}`;
    }

    function parseRanges(input, max){
      const clean = (input || "").trim();
      if(!clean) return null;
      const parts = clean.split(",").map(p => p.trim()).filter(Boolean);
      const pages = new Set();
      for(const part of parts){
        const m = part.match(/^(\d+)\s*-\s*(\d+)$/);
        if(m){
          let a = parseInt(m[1],10);
          let b = parseInt(m[2],10);
          if(Number.isNaN(a)||Number.isNaN(b)) continue;
          if(a>b) [a,b] = [b,a];
          a = Math.max(1,a); b = Math.min(max,b);
          for(let p=a;p<=b;p++) pages.add(p-1);
        }else{
          const n = parseInt(part,10);
          if(!Number.isNaN(n) && n>=1 && n<=max) pages.add(n-1);
        }
      }
      return Array.from(pages).sort((x,y)=>x-y);
    }

    function renderSteps(){
      stepsEl.innerHTML = "";
      const store = loadStore();
      STEPS.forEach((s, idx) => {
        const filled = (store[s.id] || "").trim().length > 0;
        const el = document.createElement("div");
        el.className = "step" + (s.id === activeStep ? " active" : "");
        el.innerHTML = `
          <div class="num">${idx+1}</div>
          <div class="meta">
            <div class="title">${escapeHtml(s.title)}</div>
            <div class="sub">${filled ? "Preenchida" : "Vazia"}</div>
          </div>
        `;
        el.addEventListener("click", () => {
          activeStep = s.id;
          localStorage.setItem(STORE_ACTIVE, activeStep);
          openStep(activeStep);
          renderSteps();
        });
        stepsEl.appendChild(el);
      });
      updateProgress();
    }

    function openStep(stepId){
      const s = STEPS.find(x => x.id === stepId) || STEPS[0];
      const store = loadStore();
      stepTitleEl.textContent = s.title;
      stepDescEl.textContent = s.desc;
      userTextEl.value = store[stepId] || "";
      evidenceTextEl.value = localStorage.getItem(STORE_EVID) || "";
      evidenceToggleEl.checked = (localStorage.getItem(STORE_EVID_TOGGLE) === "true");
      aiOutEl.textContent = "—";
    }

    function updateProgress(){
      const store = loadStore();
      const total = STEPS.length;
      let done = 0;
      for(const s of STEPS){
        if((store[s.id] || "").trim().length > 0) done++;
      }
      progressEl.textContent = `${Math.round((done/total)*100)}%`;
    }

    function saveCurrent(){
      const store = loadStore();
      store[activeStep] = userTextEl.value;
      saveStore(store);
      localStorage.setItem(STORE_EVID, evidenceTextEl.value);
      localStorage.setItem(STORE_EVID_TOGGLE, evidenceToggleEl.checked ? "true" : "false");
      renderSteps();
    }

    // autosave
    let autosaveTimer = null;
    function scheduleAutosave(){
      if(autosaveTimer) clearTimeout(autosaveTimer);
      autosaveTimer = setTimeout(saveCurrent, 600);
    }
    userTextEl.addEventListener("input", scheduleAutosave);
    evidenceTextEl.addEventListener("input", () => localStorage.setItem(STORE_EVID, evidenceTextEl.value));
    evidenceToggleEl.addEventListener("change", () => localStorage.setItem(STORE_EVID_TOGGLE, evidenceToggleEl.checked ? "true" : "false"));
    saveBtn.addEventListener("click", saveCurrent);

    clearStepBtn.addEventListener("click", () => {
      userTextEl.value = "";
      saveCurrent();
      aiOutEl.textContent = "—";
    });

    resetAllBtn.addEventListener("click", () => {
      localStorage.removeItem(STORE_KEY);
      localStorage.removeItem(STORE_ACTIVE);
      localStorage.removeItem(STORE_EVID);
      localStorage.removeItem(STORE_EVID_TOGGLE);
      localStorage.removeItem(STORE_PDFS);
      activeStep = STEPS[0].id;
      localStorage.setItem(STORE_ACTIVE, activeStep);
      renderSteps();
      renderPdfs();
      openStep(activeStep);
      lastSavedEl.textContent = "—";
      aiOutEl.textContent = "—";
    });

    // ---------------------------
    // HEALTH CHECK
    // ---------------------------
    async function checkHealth(){
      if(!API_BASE){
        setSvc("bad", "sem Worker");
        return;
      }
      try{
        const r = await fetch(ENDPOINT_HEALTH, { method:"GET" });
        const j = await r.json().catch(()=> ({}));
        if(r.ok && j.ok) setSvc("ok","online");
        else setSvc("bad","offline");
      }catch{
        setSvc("bad","offline");
      }
    }

    // ---------------------------
    // PDF (base64) + EXTRAÇÃO REAL
    // ---------------------------
    async function fileToDataUrl(file){
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    async function getPdfNumPages(dataUrl){
      const base64 = dataUrl.split(",")[1] || "";
      const raw = atob(base64);
      const bytes = new Uint8Array(raw.length);
      for(let i=0;i<raw.length;i++) bytes[i] = raw.charCodeAt(i);
      const pdf = await pdfjsLib.getDocument({ data: bytes }).promise;
      return pdf.numPages;
    }

    async function extractPdfText(pdfItem, opts){
      const { maxPages, maxChars, pageIndices } = opts;

      const base64 = pdfItem.dataUrl.split(",")[1] || "";
      const raw = atob(base64);
      const bytes = new Uint8Array(raw.length);
      for(let i=0;i<raw.length;i++) bytes[i] = raw.charCodeAt(i);

      const pdf = await pdfjsLib.getDocument({ data: bytes }).promise;
      const totalPages = pdf.numPages;

      const hardLimit = Math.min(totalPages, maxPages);
      let indices = pageIndices;

      if(!indices){
        indices = Array.from({length: hardLimit}, (_,i)=>i);
      }else{
        indices = indices.filter(i => i>=0 && i<totalPages);
        if(indices.length > hardLimit) indices = indices.slice(0, hardLimit);
      }

      let out = `=== PDF: ${pdfItem.name} ===\n`;
      out += `Páginas no arquivo: ${totalPages}. Extraindo: ${indices.length} página(s).\n\n`;

      let used = out.length;

      for(const idx of indices){
        const pageNo = idx + 1;
        const page = await pdf.getPage(pageNo);
        const textContent = await page.getTextContent();
        const pageText = textContent.items.map(it => (it.str || "")).join(" ").replace(/\s+/g," ").trim();

        const block = pageText
          ? `--- Página ${pageNo} ---\n${pageText}\n\n`
          : `--- Página ${pageNo} ---\n[Sem texto extraível nesta página]\n\n`;

        if(used + block.length > maxChars){
          out += `\n[Limite de caracteres atingido (${maxChars}). Interrompendo extração.]\n`;
          break;
        }
        out += block;
        used += block.length;
      }

      return { totalPages, extractedPages: indices.length, text: out };
    }

    function renderPdfs(){
      const list = loadPdfs();
      pdfListEl.innerHTML = "";

      if(list.length === 0){
        const d = document.createElement("div");
        d.className = "hint";
        d.textContent = "Nenhum PDF anexado ainda.";
        pdfListEl.appendChild(d);
        return;
      }

      for(const item of list){
        const meta = [];
        meta.push(prettyBytes(item.size || 0));
        if(item.pages) meta.push(`${item.pages} pág.`);
        if(item.lastExtract) meta.push(`extraído: ${new Date(item.lastExtract).toLocaleString()}`);

        const el = document.createElement("div");
        el.className = "fileItem";
        el.innerHTML = `
          <div class="fileTop">
            <div style="min-width:0">
              <div class="fileName" title="${escapeHtml(item.name)}">${escapeHtml(item.name)}</div>
              <div class="fileMeta">${escapeHtml(meta.join(" • "))}</div>
            </div>
            <button class="btn danger small" data-act="remove">Remover</button>
          </div>

          <div class="row" style="margin-top:10px">
            <button class="btn small" data-act="extractAll">Extrair tudo</button>
            <button class="btn small" data-act="extractRange">Extrair páginas…</button>
            <button class="btn small" data-act="preview">Ver extração</button>
          </div>

          <div class="hint" data-slot="rangeHint" style="display:none;margin-top:10px;">
            Informe páginas no formato <span class="kbd">1-3, 7, 10-12</span> e clique Extrair.
          </div>

          <div class="row" data-slot="rangeUi" style="display:none;margin-top:10px;">
            <input data-slot="rangeInput" type="text" value="1-3"
              style="flex:1;min-width:180px;padding:10px;border-radius:14px;border:1px solid var(--line);background:rgba(255,255,255,.04);color:var(--text);font-weight:900;outline:none;">
            <button class="btn primary small" data-act="confirmRange">Extrair</button>
          </div>
        `;

        el.querySelector('[data-act="remove"]').addEventListener("click", () => {
          savePdfs(loadPdfs().filter(x => x.id !== item.id));
        });

        el.querySelector('[data-act="extractAll"]').addEventListener("click", async () => {
          await doExtract(item.id, null);
        });

        el.querySelector('[data-act="extractRange"]').addEventListener("click", () => {
          const rangeHint = el.querySelector('[data-slot="rangeHint"]');
          const rangeUi = el.querySelector('[data-slot="rangeUi"]');
          const show = rangeUi.style.display === "none";
          rangeHint.style.display = show ? "block" : "none";
          rangeUi.style.display = show ? "flex" : "none";
        });

        el.querySelector('[data-act="confirmRange"]').addEventListener("click", async () => {
          const v = el.querySelector('[data-slot="rangeInput"]').value || "";
          await doExtract(item.id, v.trim());
        });

        el.querySelector('[data-act="preview"]').addEventListener("click", () => {
          const now = loadPdfs().find(x => x.id === item.id);
          aiOutEl.textContent = (now && now.extractedText) ? now.extractedText : "Ainda não há texto extraído deste PDF.";
        });

        pdfListEl.appendChild(el);
      }
    }

    async function doExtract(pdfId, rangeStr){
      const list = loadPdfs();
      const item = list.find(x => x.id === pdfId);
      if(!item){
        aiOutEl.textContent = "PDF não encontrado.";
        return;
      }

      const maxPages = clampInt(maxPagesEl.value, 1, 200, 30);
      const maxChars = clampInt(maxCharsEl.value, 5000, 300000, 60000);

      runtimeStatusEl.textContent = "extraindo PDF…";
      aiOutEl.textContent = "Extraindo texto do PDF… (pode levar alguns segundos)";

      try{
        let pageIndices = null;
        if(rangeStr){
          const numPages = await getPdfNumPages(item.dataUrl);
          pageIndices = parseRanges(rangeStr, numPages);
          if(!pageIndices || pageIndices.length === 0){
            runtimeStatusEl.textContent = "pronto";
            aiOutEl.textContent = "Faixa inválida. Use por exemplo: 1-3, 7, 10-12";
            return;
          }
        }

        const res = await extractPdfText(item, { maxPages, maxChars, pageIndices });

        //  atualiza metadados + cache de extração
        const updated = loadPdfs().map(x => {
          if(x.id !== item.id) return x;
          return {
            ...x,
            pages: res.totalPages,
            extractedText: res.text,
            lastExtract: Date.now()
          };
        });
        savePdfs(updated);

        // joga o texto extraído para o campo de evidências (append)
        const current = evidenceTextEl.value || "";
        evidenceTextEl.value = (current ? (current.trimEnd() + "\n\n") : "") + res.text;
        localStorage.setItem(STORE_EVID, evidenceTextEl.value);

        runtimeStatusEl.textContent = "pronto";
        aiOutEl.textContent = "Texto extraído e inserido em Evidências com sucesso.";
      }catch(err){
        runtimeStatusEl.textContent = "erro";
        aiOutEl.textContent = "Falha ao extrair PDF: " + (err?.message || String(err));
      }
    }

    // Upload PDFs
    pdfInputEl.addEventListener("change", async (ev) => {
      const files = Array.from(ev.target.files || []);
      if(files.length === 0) return;

      runtimeStatusEl.textContent = "anexando PDFs…";
      aiOutEl.textContent = "Anexando PDFs…";

      try{
        const list = loadPdfs();
        for(const file of files){
          if(file.type !== "application/pdf") continue;

          const dataUrl = await fileToDataUrl(file);
          list.push({
            id: crypto?.randomUUID ? crypto.randomUUID() : (Date.now() + "_" + Math.random().toString(16).slice(2)),
            name: file.name,
            size: file.size,
            dataUrl,
            pages: null,
            extractedText: "",
            lastExtract: null
          });
        }
        savePdfs(list);
        runtimeStatusEl.textContent = "pronto";
        aiOutEl.textContent = "PDF(s) anexado(s). Agora você pode extrair texto para Evidências.";
      }catch(err){
        runtimeStatusEl.textContent = "erro";
        aiOutEl.textContent = "Falha ao anexar PDF: " + (err?.message || String(err));
      }finally{
        // permite anexar o mesmo arquivo novamente
        pdfInputEl.value = "";
      }
    });

    clearPdfsBtn.addEventListener("click", () => {
      localStorage.removeItem(STORE_PDFS);
      renderPdfs();
      aiOutEl.textContent = "PDFs removidos.";
    });

    // ---------------------------
    // CHAMADA IA (POST /assist)
    // ---------------------------
    function buildPrompt(){
      const s = STEPS.find(x => x.id === activeStep) || STEPS[0];
      const userText = (userTextEl.value || "").trim();
      const evid = (evidenceTextEl.value || "").trim();
      const useEvidence = evidenceToggleEl.checked;

      // Prompt bem objetivo e "humano" (sem robô)
      let prompt = `Você é um orientador acadêmico. Ajude o aluno na etapa: "${s.title}".\n`;
      prompt += `Descrição da etapa: ${s.desc}\n\n`;
      prompt += `Texto do aluno:\n${userText || "[vazio]"}\n\n`;

      if(useEvidence){
        prompt += `Use APENAS as evidências abaixo como base para citações e justificativas.`;
        prompt += ` Se faltar evidência, diga claramente o que falta.\n\n`;
        prompt += `Evidências:\n${evid || "[sem evidências fornecidas]"}\n\n`;
      }else if(evid){
        prompt += `Observação: há evidências/anotações, mas você pode usar também conhecimento geral.\n\n`;
        prompt += `Anotações/Evidências:\n${evid}\n\n`;
      }

      prompt += `Entregue:\n`;
      prompt += `1) Diagnóstico curto (o que está bom e o que falta)\n`;
      prompt += `2) Uma versão reescrita/melhorada do texto (mantendo autoria do aluno)\n`;
      prompt += `3) Lista de próximos passos práticos\n`;
      return prompt;
    }

    async function callAssist(){
      if(!API_BASE){
        runtimeStatusEl.textContent = "erro";
        aiOutEl.textContent = "Você não configurou o WORKER_BASE. Cole o link do Worker Cloudflare na constante WORKER_BASE.";
        return;
      }

      const prompt = buildPrompt();

      runtimeStatusEl.textContent = "consultando IA…";
      aiOutEl.textContent = "Chamando a IA…";

      try{
        const r = await fetch(ENDPOINT_ASSIST, {
          method: "POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify({
            prompt,
            step: activeStep,
            evidence_mode: evidenceToggleEl.checked
          })
        });

        const text = await r.text(); // primeiro lê texto (pode vir HTML em erro)
        let data = null;
        try{ data = JSON.parse(text); }catch{ /* pode não ser JSON */ }

        if(!r.ok){
          runtimeStatusEl.textContent = "erro";

          // Erro 405 clássico: está indo para o lugar errado ou método errado
          if(r.status === 405){
            aiOutEl.textContent =
              "Falha ao chamar /assist (HTTP 405)\n\n" +
              "Isso acontece quando:\n" +
              "1) Você está chamando o endpoint do GitHub Pages (relativo) e não o Worker.\n" +
              "2) O WORKER_BASE não foi preenchido corretamente.\n\n" +
              "Confira:\n" +
              "- WORKER_BASE precisa ser algo como: https://SEU-WORKER.workers.dev\n" +
              "- E o endpoint final deve aparecer no rodapé (Endpoint).\n\n" +
              "Resposta recebida:\n" + text;
            return;
          }

          aiOutEl.textContent =
            `Erro HTTP ${r.status}\n\n` +
            (data?.error ? `Mensagem: ${data.error}\n\n` : "") +
            "Resposta:\n" + text;
          return;
        }

        // Sucesso: tenta extrair um campo "text"/"response"/"output"
        const out =
          data?.text ||
          data?.response ||
          data?.output ||
          data?.message ||
          text;

        runtimeStatusEl.textContent = "pronto";
        aiOutEl.textContent = out;
      }catch(err){
        runtimeStatusEl.textContent = "erro";
        aiOutEl.textContent = "Falha ao chamar a IA: " + (err?.message || String(err));
      }
    }

    askBtn.addEventListener("click", callAssist);

    // ---------------------------
    // EXPORTAÇÃO
    // ---------------------------
    exportPdfBtn.addEventListener("click", () => {
      // Export PDF via print
      window.print();
    });

    exportDocxBtn.addEventListener("click", async () => {
      try{
        if(!window.docx || !window.saveAs){
          aiOutEl.textContent = "Bibliotecas DOCX não carregaram. Recarregue a página e tente novamente.";
          return;
        }

        const s = STEPS.find(x => x.id === activeStep) || STEPS[0];
        const userText = (userTextEl.value || "").trim();
        const evid = (evidenceTextEl.value || "").trim();
        const ai = (aiOutEl.textContent || "").trim();

        const { Document, Packer, Paragraph, HeadingLevel } = window.docx;

        const doc = new Document({
          sections: [{
            properties: {},
            children: [
              new Paragraph({ text: "Orientador de TCC Digital", heading: HeadingLevel.TITLE }),
              new Paragraph({ text: `Etapa: ${s.title}`, heading: HeadingLevel.HEADING_1 }),
              new Paragraph({ text: s.desc }),
              new Paragraph({ text: "" }),

              new Paragraph({ text: "Texto do aluno", heading: HeadingLevel.HEADING_2 }),
              ...splitToParagraphs(userText || "[vazio]").map(t => new Paragraph(t)),

              new Paragraph({ text: "" }),
              new Paragraph({ text: "Evidências / Anotações", heading: HeadingLevel.HEADING_2 }),
              ...splitToParagraphs(evid || "[vazio]").map(t => new Paragraph(t)),

              new Paragraph({ text: "" }),
              new Paragraph({ text: "Resposta da IA", heading: HeadingLevel.HEADING_2 }),
              ...splitToParagraphs(ai || "[vazio]").map(t => new Paragraph(t)),
            ],
          }],
        });

        const blob = await Packer.toBlob(doc);
        window.saveAs(blob, `orientador-${activeStep}.docx`);
        aiOutEl.textContent = "DOCX gerado com sucesso.";
      }catch(err){
        aiOutEl.textContent = "Falha ao exportar DOCX: " + (err?.message || String(err));
      }
    });

    function splitToParagraphs(text){
      return String(text || "")
        .replace(/\r/g,"")
        .split("\n")
        .map(l => l.trimEnd())
        .filter(l => l.length > 0);
    }

    // ---------------------------
    // INIT
    // ---------------------------
    function init(){
      renderSteps();
      renderPdfs();
      openStep(activeStep);
      checkHealth();
      setInterval(checkHealth, 20000);
    }

    init();
  </script>
</body>
</html>
