<script>
  /* =========================================================
     ORIENTADOR TCC DIGITAL — Single-file app
  ========================================================= */

  // PDF.js worker
  if (window.pdfjsLib) {
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.worker.min.js";
  }

  const $ = (sel) => document.querySelector(sel);

  const el = {
    // top + drawer
    btnMenu: $("#btnMenu"),
    drawer: $("#drawer"),
    drawerOverlay: $("#drawerOverlay"),
    btnCloseDrawer: $("#btnCloseDrawer"),

    statusBadge: $("#statusBadge"),

    // progress
    progressValue: $("#progressValue"),
    progressFill: $("#progressFill"),

    // evidence
    evidenceMode: $("#evidenceMode"),

    // etapa
    etapaSelect: $("#etapaSelect"),

    // main meta
    workerEndpoint: $("#workerEndpoint"),
    projectTitle: $("#projectTitle"),
    authorName: $("#authorName"),
    institutionName: $("#institutionName"),

    // editor
    studentText: $("#studentText"),
    sectionEditorTitle: $("#sectionEditorTitle"),
    sectionEditorSubtitle: $("#sectionEditorSubtitle"),
    sectionEditorText: $("#sectionEditorText"),

    // buttons
    btnGenerateSection: $("#btnGenerateSection"),
    btnApplyBriefing: $("#btnApplyBriefing"),
    btnSaveSection: $("#btnSaveSection"),
    btnQuickSave: $("#btnQuickSave"),

    // attachments
    fileInput: $("#fileInput"),
    attachmentsList: $("#attachmentsList"),

    // exports
    btnExportPDF: $("#btnExportPDF"),
    btnExportDOCX: $("#btnExportDOCX"),

    // terminal
    terminal: $("#terminal"),

    // drawer fields
    workerEndpointMenu: $("#workerEndpointMenu"),
    projectTitleMenu: $("#projectTitleMenu"),
    authorNameMenu: $("#authorNameMenu"),
    institutionNameMenu: $("#institutionNameMenu"),
    evidenceModeMenu: $("#evidenceModeMenu"),
    btnSaveConfig: $("#btnSaveConfig"),
    btnResetConfig: $("#btnResetConfig"),

    // PDF import
    pdfInput: $("#pdfInput"),
    btnExtractPDF: $("#btnExtractPDF"),
    btnImportPDFToSection: $("#btnImportPDFToSection"),
    pdfExtractedText: $("#pdfExtractedText"),
  };

  const LS_KEY = "orientador_tcc_state_v2";

  const TCC_STRUCTURE = [
    { id: "capa", title: "Capa (informações)", required: true },
    { id: "resumo", title: "Resumo", required: true },
    { id: "abstract", title: "Abstract", required: false },
    { id: "introducao", title: "1. Introdução", required: true },
    { id: "problema", title: "2. Problema de Pesquisa", required: true },
    { id: "objetivo_geral", title: "3. Objetivo Geral", required: true },
    { id: "objetivos_especificos", title: "4. Objetivos Específicos", required: true },
    { id: "justificativa", title: "5. Justificativa", required: true },
    { id: "referencial", title: "6. Referencial Teórico", required: true },
    { id: "metodologia", title: "7. Metodologia", required: true },
    { id: "resultados", title: "8. Resultados (ou Resultados Esperados)", required: false },
    { id: "cronograma", title: "9. Cronograma", required: false },
    { id: "consideracoes_finais", title: "10. Considerações Finais", required: true },
    { id: "referencias", title: "Referências", required: true },
    { id: "apendices", title: "Apêndices", required: false },
    { id: "anexos", title: "Anexos", required: false },
  ];

  const DEFAULT_STATE = {
    config: {
      workerEndpoint: "https://icy-heart-f16a.vitorjoseivan.workers.dev/assist",
      evidenceMode: false,
    },
    meta: {
      projectTitle: "Orientador de TCC Digital",
      authorName: "José Ivan Vitor Cordeiro",
      institutionName: "Universidade Estadual do Ceará (UECE)",
    },
    selectedSectionId: "introducao",
    sections: TCC_STRUCTURE.reduce((acc, s) => {
      acc[s.id] = { title: s.title, content: "" };
      return acc;
    }, {}),
    attachments: [],
    pdfLastExtract: "",
  };

  let state = loadState();

  function safeParse(raw){ try{ return JSON.parse(raw); }catch{ return null; } }

  function normalizeEndpoint(url){
    const u = (url || "").trim();
    if (!u) return "";
    if (u.endsWith("/assist")) return u;
    return u.replace(/\/+$/, "") + "/assist";
  }

  function loadState(){
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return structuredClone(DEFAULT_STATE);
    const parsed = safeParse(raw);
    if (!parsed) return structuredClone(DEFAULT_STATE);

    const s = structuredClone(DEFAULT_STATE);
    s.config = { ...s.config, ...(parsed.config || {}) };
    s.meta = { ...s.meta, ...(parsed.meta || {}) };
    s.selectedSectionId = parsed.selectedSectionId || s.selectedSectionId;
    s.sections = { ...s.sections, ...(parsed.sections || {}) };
    s.attachments = Array.isArray(parsed.attachments) ? parsed.attachments : [];
    s.pdfLastExtract = String(parsed.pdfLastExtract || "");
    return s;
  }

  function saveState(){
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }

  function setDrawer(open){
    el.drawer.dataset.open = open ? "true" : "false";
    el.drawer.setAttribute("aria-hidden", open ? "false" : "true");
  }

  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, s => ({
      "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;"
    }[s]));
  }

  function setBadge(text, ok=true){
    el.statusBadge.innerHTML = ok
      ? `<span class="dot"></span>${escapeHtml(text)}`
      : `<span class="dot" style="background: var(--danger); box-shadow: 0 0 0 5px rgba(239,68,68,.14)"></span>${escapeHtml(text)}`;
  }

  function logTerminal(msg, append=false){
    if (!append) el.terminal.textContent = String(msg ?? "");
    else el.terminal.textContent = el.terminal.textContent + "\n" + String(msg ?? "");
  }

  function calcProgress(){
    const required = TCC_STRUCTURE.filter(s => s.required);
    const total = required.length || 1;
    const done = required.filter(s => (state.sections?.[s.id]?.content || "").trim().length > 30).length;
    return Math.round((done / total) * 100);
  }

  function renderProgress(){
    const pct = calcProgress();
    el.progressValue.textContent = `${pct}%`;
    el.progressFill.style.width = `${pct}%`;
    const pb = document.querySelector(".progress");
    if (pb) pb.setAttribute("aria-valuenow", String(pct));
  }

  function sectionToEtapa(sectionId){
    const map = {
      introducao: "introducao",
      problema: "problema",
      objetivo_geral: "objetivo_geral",
      objetivos_especificos: "objetivos_especificos",
      justificativa: "justificativa",
      referencial: "referencial",
      metodologia: "metodologia",
      resultados: "resultados",
      consideracoes_finais: "consideracoes_finais",
      referencias: "referencias",
      resumo: "resumo",
      abstract: "abstract",
    };
    return map[sectionId] || "tema";
  }

  function renderSectionsList(){
    const list = document.querySelector("#sectionsList");
    list.innerHTML = "";

    for (const s of TCC_STRUCTURE){
      const content = (state.sections?.[s.id]?.content || "").trim();
      const isDone = content.length > 30;

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "section-item" + (state.selectedSectionId === s.id ? " active" : "");
      btn.innerHTML = `
        <div class="section-left">
          <div class="section-title">${escapeHtml(s.title)}</div>
          <div class="section-meta">${s.required ? "Obrigatório" : "Opcional"} • ${isDone ? "Preenchido" : "Vazio"}</div>
        </div>
        <div class="section-right">${isDone ? "✓" : ""}</div>
      `;
      btn.addEventListener("click", () => {
        state.selectedSectionId = s.id;
        saveState();
        syncSectionEditor();
        renderSectionsList();
      });

      list.appendChild(btn);
    }
  }

  function syncMetaToInputs(){
    el.workerEndpoint.value = state.config.workerEndpoint || "";
    el.projectTitle.value = state.meta.projectTitle || "";
    el.authorName.value = state.meta.authorName || "";
    el.institutionName.value = state.meta.institutionName || "";
    el.evidenceMode.checked = !!state.config.evidenceMode;

    el.workerEndpointMenu.value = state.config.workerEndpoint || "";
    el.projectTitleMenu.value = state.meta.projectTitle || "";
    el.authorNameMenu.value = state.meta.authorName || "";
    el.institutionNameMenu.value = state.meta.institutionName || "";
    el.evidenceModeMenu.checked = !!state.config.evidenceMode;

    el.pdfExtractedText.value = state.pdfLastExtract || "";
  }

  function syncSectionEditor(){
    const sid = state.selectedSectionId;
    const sec = state.sections?.[sid] || { title: sid, content: "" };

    el.sectionEditorTitle.textContent = sec.title || sid;
    el.sectionEditorSubtitle.textContent = `Seção: ${sec.title || sid}`;
    el.sectionEditorText.value = sec.content || "";

    el.etapaSelect.value = sectionToEtapa(sid);
  }

  function renderAttachments(){
    el.attachmentsList.innerHTML = "";
    if (!state.attachments.length){
      el.attachmentsList.innerHTML = `<div class="muted">Nenhum anexo ainda.</div>`;
      return;
    }

    state.attachments.forEach((a, idx) => {
      const row = document.createElement("div");
      row.className = "attachment";
      row.innerHTML = `
        <div>
          <div class="name">${escapeHtml(a.name)}</div>
          <div class="meta">${escapeHtml(a.type || "arquivo")} • ${(Number(a.size||0)/1024).toFixed(1)} KB</div>
        </div>
        <button class="btn small ghost" type="button">Remover</button>
      `;
      row.querySelector("button").addEventListener("click", () => {
        state.attachments.splice(idx, 1);
        saveState();
        renderAttachments();
      });
      el.attachmentsList.appendChild(row);
    });
  }

  function hydrate(){
    syncMetaToInputs();
    renderSectionsList();
    syncSectionEditor();
    renderAttachments();
    renderProgress();
    logTerminal("Aguardando...\nDica: configure o endpoint do Worker em Configurações.");
  }

  /* ===================== Worker ===================== */

  async function callWorker({ endpoint, etapa, text, evidenceMode }){
    const payload = { etapa, texto: text, modo_evidencia: !!evidenceMode };

    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), 25000);

    try{
      const res = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        signal: controller.signal,
      });

      const ct = res.headers.get("content-type") || "";
      const data = ct.includes("application/json")
        ? await res.json()
        : { text: await res.text() };

      if (!res.ok) {
        const msg = data?.error || data?.message || `HTTP ${res.status}`;
        throw new Error(msg);
      }
      return data;
    } finally {
      clearTimeout(t);
    }
  }

  function getEndpointFromInputs(){
    const raw = (el.workerEndpoint.value || "").trim();
    return normalizeEndpoint(raw);
  }

  async function onGenerate(){
    const briefing = (el.studentText.value || "").trim();
    if (!briefing){
      setBadge("Escreva um briefing primeiro", false);
      logTerminal("Escreva um briefing do aluno antes de gerar.");
      return;
    }

    const endpoint = getEndpointFromInputs();
    if (!endpoint || !endpoint.startsWith("http")){
      setBadge("Endpoint inválido", false);
      logTerminal("Endpoint do Worker inválido.\nExemplo: https://seu-worker.workers.dev/assist");
      return;
    }

    state.config.workerEndpoint = endpoint;
    state.config.evidenceMode = !!el.evidenceMode.checked;
    saveState();

    const etapa = el.etapaSelect.value || sectionToEtapa(state.selectedSectionId);

    setBadge("Gerando...", true);
    logTerminal(`Chamando Worker...\nEtapa: ${etapa}\nEndpoint: ${endpoint}\n`);

    try{
      const data = await callWorker({
        endpoint,
        etapa,
        text: briefing,
        evidenceMode: state.config.evidenceMode,
      });

      const generated =
        (typeof data === "string" ? data :
         data?.texto || data?.text || data?.result || data?.output || "");

      if (!String(generated).trim()){
        setBadge("Worker respondeu vazio", false);
        logTerminal("O Worker respondeu, mas sem texto. Verifique o formato de retorno no Worker.");
        return;
      }

      el.sectionEditorText.value = String(generated).trim();
      setBadge("Texto gerado", true);
      logTerminal("Texto gerado com sucesso.\nSalve a seção para armazenar no documento.");

    } catch (err){
      setBadge("Erro ao chamar Worker", false);

      const msg = String(err?.message || err || "Erro desconhecido");
      logTerminal(
`ERRO ao chamar o Worker:
${msg}

Se for "Failed to fetch", causas comuns:
1) CORS no Worker (precisa responder OPTIONS e Allow-Origin)
2) Endpoint errado (deve terminar em /assist)
3) Worker fora do ar

Verifique: Cloudflare Workers > seu Worker > Logs.`
      );
    }
  }

  /* ===================== PDF.js ===================== */

  async function extractTextFromPDF(file){
    if (!window.pdfjsLib) throw new Error("PDF.js não carregou.");
    const buffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: buffer }).promise;

    let fullText = [];
    for (let p = 1; p <= pdf.numPages; p++){
      const page = await pdf.getPage(p);
      const content = await page.getTextContent();
      const strings = content.items.map(it => it.str).filter(Boolean);
      const pageText = strings.join(" ").replace(/\s+/g, " ").trim();
      if (pageText) fullText.push(`[Página ${p}] ${pageText}`);
    }
    return fullText.join("\n\n");
  }

  async function onExtractPDF(){
    const file = el.pdfInput.files?.[0];
    if (!file){
      setBadge("Selecione um PDF", false);
      logTerminal("Selecione um arquivo PDF primeiro.");
      return;
    }

    setBadge("Extraindo PDF...", true);
    logTerminal(`Extraindo texto real do PDF: ${file.name}`);

    try{
      const text = await extractTextFromPDF(file);
      if (!text.trim()){
        setBadge("PDF sem texto", false);
        el.pdfExtractedText.value = "";
        state.pdfLastExtract = "";
        saveState();
        logTerminal("Não foi possível extrair texto.\nEsse PDF pode ser escaneado (imagem) ou protegido.");
        return;
      }

      el.pdfExtractedText.value = text;
      state.pdfLastExtract = text;
      saveState();

      setBadge("PDF extraído", true);
      logTerminal("Texto extraído com sucesso.\nVocê pode importar para a seção atual ou copiar trechos.");

    } catch (err){
      setBadge("Falha ao extrair PDF", false);
      logTerminal("Erro ao extrair PDF:\n" + String(err?.message || err));
    }
  }

  function onImportPDFToSection(){
    const text = (el.pdfExtractedText.value || "").trim();
    if (!text){
      setBadge("Sem texto para importar", false);
      logTerminal("Extraia o PDF primeiro. Não há texto para importar.");
      return;
    }
    const current = (el.sectionEditorText.value || "").trim();
    const merged = current ? (current + "\n\n" + text) : text;
    el.sectionEditorText.value = merged;
    setBadge("Importado na seção", true);
    logTerminal("Texto do PDF importado no editor.\nAgora revise e salve a seção.");
  }

  /* ===================== Save / Apply ===================== */

  function onApplyBriefing(){
    const briefing = (el.studentText.value || "").trim();
    if (!briefing){
      setBadge("Escreva um briefing", false);
      logTerminal("Escreva um briefing primeiro para aplicar na seção.");
      return;
    }
    el.sectionEditorText.value = briefing;
    setBadge("Briefing aplicado", true);
    logTerminal("Briefing aplicado no editor.\nAgora edite e/ou gere com IA.");
  }

  function onSaveSection(){
    const sid = state.selectedSectionId;
    const txt = (el.sectionEditorText.value || "").trim();
    state.sections[sid] = state.sections[sid] || { title: sid, content: "" };
    state.sections[sid].content = txt;

    state.meta.projectTitle = (el.projectTitle.value || "").trim();
    state.meta.authorName = (el.authorName.value || "").trim();
    state.meta.institutionName = (el.institutionName.value || "").trim();
    state.config.workerEndpoint = normalizeEndpoint(el.workerEndpoint.value || "");
    state.config.evidenceMode = !!el.evidenceMode.checked;

    saveState();
    renderProgress();
    renderSectionsList();

    setBadge("Seção salva", true);
    logTerminal(`Seção salva: ${state.sections[sid].title}\nProgresso: ${calcProgress()}%`);
  }

  function onQuickSave(){
    onSaveSection();
  }

  /* ===================== Attachments ===================== */

  function onFilesSelected(){
    const files = Array.from(el.fileInput.files || []);
    if (!files.length) return;

    for (const f of files){
      state.attachments.push({
        name: f.name,
        type: f.type || "arquivo",
        size: f.size || 0,
        lastModified: f.lastModified || Date.now(),
      });
    }
    saveState();
    renderAttachments();
    setBadge("Anexos adicionados", true);
    logTerminal(`Anexos adicionados: ${files.map(f=>f.name).join(", ")}`);
    el.fileInput.value = "";
  }

  /* ===================== Export PDF / DOCX ===================== */
  // Mantive as funções exportPDF() e exportDOCX() como você já tinha no arquivo.
  // Se você já colou elas acima, OK. Se não, avise que eu te entrego o bloco completo.

  /* ===================== Drawer Config ===================== */

  function onSaveConfig(){
    const endpoint = normalizeEndpoint(el.workerEndpointMenu.value || "");
    state.config.workerEndpoint = endpoint;
    state.config.evidenceMode = !!el.evidenceModeMenu.checked;

    state.meta.projectTitle = (el.projectTitleMenu.value || "").trim();
    state.meta.authorName = (el.authorNameMenu.value || "").trim();
    state.meta.institutionName = (el.institutionNameMenu.value || "").trim();

    saveState();
    syncMetaToInputs();
    setDrawer(false);
    setBadge("Config salva", true);
    logTerminal("Configurações salvas no navegador.");
  }

  function onResetConfig(){
    state.config = structuredClone(DEFAULT_STATE.config);
    state.meta = structuredClone(DEFAULT_STATE.meta);
    saveState();
    syncMetaToInputs();
    setBadge("Padrão restaurado", true);
    logTerminal("Configurações padrão restauradas.");
  }

  /* ===================== Events (a parte que faltou) ===================== */

  // Drawer
  el.btnMenu.addEventListener("click", () => setDrawer(true));
  el.drawerOverlay.addEventListener("click", () => setDrawer(false));
  el.btnCloseDrawer.addEventListener("click", () => setDrawer(false));

  // IA / Save
  el.btnGenerateSection.addEventListener("click", onGenerate);
  el.btnApplyBriefing.addEventListener("click", onApplyBriefing);
  el.btnSaveSection.addEventListener("click", onSaveSection);
  el.btnQuickSave.addEventListener("click", onQuickSave);

  // PDF import
  el.btnExtractPDF.addEventListener("click", onExtractPDF);
  el.btnImportPDFToSection.addEventListener("click", onImportPDFToSection);

  // Attachments
  el.fileInput.addEventListener("change", onFilesSelected);

  // Exports
  el.btnExportPDF.addEventListener("click", () => {
    if (typeof exportPDF === "function") exportPDF();
    else {
      setBadge("Função exportPDF ausente", false);
      logTerminal("A função exportPDF() não está no arquivo. Cole o bloco de exportação PDF.");
    }
  });

  el.btnExportDOCX.addEventListener("click", async () => {
    if (typeof exportDOCX === "function") await exportDOCX();
    else {
      setBadge("Função exportDOCX ausente", false);
      logTerminal("A função exportDOCX() não está no arquivo. Cole o bloco de exportação DOCX.");
    }
  });

  // Menu config buttons
  el.btnSaveConfig.addEventListener("click", onSaveConfig);
  el.btnResetConfig.addEventListener("click", onResetConfig);

  // Sync meta live
  el.workerEndpoint.addEventListener("change", () => {
    state.config.workerEndpoint = normalizeEndpoint(el.workerEndpoint.value || "");
    saveState();
    syncMetaToInputs();
  });
  el.evidenceMode.addEventListener("change", () => {
    state.config.evidenceMode = !!el.evidenceMode.checked;
    saveState();
    syncMetaToInputs();
  });

  // Init
  hydrate();
</script>
</body>
</html>
